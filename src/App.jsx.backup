// src/App.jsx
import { useEffect, useMemo, useState } from "react";
import TaskMarketplaceUtils from "./utils/TaskMarketplaceUtils";
import { initIPFS } from "./utils/ipfsUtils";
import "./App.css";

// âœ… update this after deploy
const SEPOLIA_CONTRACT_ADDRESS = "0xB12210a69c508AaA54504908e09c5a4383f026c8";
const SEPOLIA_CHAIN_ID = "11155111";

// status mapping must match your contract enum order
const STATUS = {
  Open: 0,
  InProgress: 1,
  PendingApproval: 2,
  Completed: 3,
  Cancelled: 4,
};

const ZERO_ADDR = "0x0000000000000000000000000000000000000000";

export default function App() {
  const [utils, setUtils] = useState(null);

  const [account, setAccount] = useState("");
  const [balance, setBalance] = useState("0");
  const [withdrawable, setWithdrawable] = useState("0");
  const [networkInfo, setNetworkInfo] = useState(null);

  // tasks
  const [openTasks, setOpenTasks] = useState([]);
  const [myCreatedTasks, setMyCreatedTasks] = useState([]);
  const [myWorkerTasks, setMyWorkerTasks] = useState([]);

  // ui state
  const [currentView, setCurrentView] = useState("marketplace"); // marketplace | myTasks | create | taskDetail
  const [selectedTaskId, setSelectedTaskId] = useState(null); // for task detail view
  const [selectedTask, setSelectedTask] = useState(null); // full task object
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");

  // search / filters (Marketplace)
  const [searchQuery, setSearchQuery] = useState("");
  const [statusFilter, setStatusFilter] = useState("all"); // all | open | inprogress | pendingapproval | completed | cancelled
  const [sortBy, setSortBy] = useState("newest"); // newest | rewardHigh | rewardLow | deadlineSoon

  // comments (optional, if supported by your utils + contract)
  const [comments, setComments] = useState({}); // { [taskId]: [{taskId, author, message, timestamp}] }
  const [commentInput, setCommentInput] = useState({}); // { [taskId]: "..." }

  // form
  const [newTask, setNewTask] = useState({
    title: "",
    description: "",
    reward: "",
    deadline: "",
  });
  
  // âœ… File uploads state
  const [attachments, setAttachments] = useState([]);
  const [uploadingFiles, setUploadingFiles] = useState(false);

  // init utils
  useEffect(() => {
    setUtils(new TaskMarketplaceUtils(SEPOLIA_CONTRACT_ADDRESS));
    // âœ… Initialize IPFS client on app load
    initIPFS().catch(e => console.warn("IPFS init failed:", e));
  }, []);

  // helpers
  const isConnected = useMemo(
    () => Boolean(account && utils?.isConnected?.()),
    [account, utils]
  );

  const wrongNetwork =
    networkInfo?.chainId && networkInfo.chainId !== SEPOLIA_CHAIN_ID;

  const normalize = (s) => (s ?? "").toString().toLowerCase().trim();

  const formatDateTime = (timestamp) => {
    if (!timestamp) return "-";
    return new Date(Number(timestamp) * 1000).toLocaleString();
  };

  const formatAddress = (addr) => {
    if (!addr) return "-";
    return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
  };

  const clearMessagesSoon = () => {
    setTimeout(() => {
      setError("");
      setSuccess("");
    }, 4000);
  };

  const statusKeyFromTask = (task) => {
    const s = normalize(task?.statusText);
    if (s) return s;

    switch (task?.status) {
      case STATUS.Open:
        return "open";
      case STATUS.InProgress:
        return "inprogress";
      case STATUS.PendingApproval:
        return "pendingapproval";
      case STATUS.Completed:
        return "completed";
      case STATUS.Cancelled:
        return "cancelled";
      default:
        return "all";
    }
  };

  const matchesSearch = (task, q) => {
    const query = normalize(q);
    if (!query) return true;

    const hay = [
      task?.id,
      task?.title,
      task?.description,
      task?.creator,
      task?.worker,
      task?.statusText,
    ]
      .map((x) => normalize(x))
      .join(" ");

    return hay.includes(query);
  };

  const applyFiltersAndSort = (tasks) => {
    const q = searchQuery;

    let filtered = (tasks ?? []).filter((t) => {
      const okSearch = matchesSearch(t, q);
      const key = statusKeyFromTask(t);
      const okStatus = statusFilter === "all" ? true : key === statusFilter;
      return okSearch && okStatus;
    });

    const toNum = (v) => {
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    };

    filtered = filtered.slice().sort((a, b) => {
      if (sortBy === "rewardHigh") return toNum(b.reward) - toNum(a.reward);
      if (sortBy === "rewardLow") return toNum(a.reward) - toNum(b.reward);
      if (sortBy === "deadlineSoon") return toNum(a.deadline) - toNum(b.deadline);
      return toNum(b.id) - toNum(a.id); // newest
    });

    return filtered;
  };

  // âœ… compute once per render
  const filteredOpen = useMemo(
    () => applyFiltersAndSort(openTasks),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [openTasks, searchQuery, statusFilter, sortBy]
  );

  const handleDisconnect = () => {
    utils?.removeAllListeners?.();
    setAccount("");
    setBalance("0");
    setWithdrawable("0");
    setNetworkInfo(null);
    setOpenTasks([]);
    setMyCreatedTasks([]);
    setMyWorkerTasks([]);
    setCurrentView("marketplace");
    setSuccess("Wallet disconnected in UI. Reconnect to continue.");
    clearMessagesSoon();
  };

  // MetaMask account changes
  useEffect(() => {
    if (!window.ethereum) return;

    const onAccountsChanged = async (accounts) => {
      if (!accounts || accounts.length === 0) {
        handleDisconnect();
        return;
      }

      const next = accounts[0];
      if (next?.toLowerCase?.() !== account?.toLowerCase?.()) {
        setAccount(next);
        setSuccess("Account switched. Reloading data...");
        clearMessagesSoon();

        if (utils) {
          const res = await utils.connectWallet();
          if (res.success) {
            setAccount(res.address);
            setBalance(res.balance);
            await loadBalances(res.address);
            await loadTasks(res.address);
          }
        }
      }
    };

    window.ethereum.on("accountsChanged", onAccountsChanged);
    return () => window.ethereum.removeListener("accountsChanged", onAccountsChanged);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [account, utils]);

  // event listeners
  useEffect(() => {
    if (!utils || !isConnected) return;

    utils.removeAllListeners();

    utils.onTaskCreated?.(() => {
      setSuccess("Task created!");
      clearMessagesSoon();
      setTimeout(() => loadTasks(account), 1200);
    });

    utils.onTaskTaken?.(() => {
      setSuccess("Task taken!");
      clearMessagesSoon();
      setTimeout(() => loadTasks(account), 1200);
    });

    utils.onWorkSubmitted?.(() => {
      setSuccess("Work submitted. Waiting creator approval.");
      clearMessagesSoon();
      setTimeout(() => loadTasks(account), 1200);
    });

    utils.onTaskApproved?.(() => {
      setSuccess("Work approved. Reward is now withdrawable.");
      clearMessagesSoon();
      setTimeout(async () => {
        await loadTasks(account);
        await loadBalances(account);
      }, 1200);
    });

    utils.onTaskCancelled?.(() => {
      setSuccess("Task cancelled. Funds are withdrawable (if you were the creator).");
      clearMessagesSoon();
      setTimeout(async () => {
        await loadTasks(account);
        await loadBalances(account);
      }, 1200);
    });

    // optional: comments event
    utils.onTaskComment?.((c) => {
      // expecting: { taskId, author, message, timestamp }
      setComments((prev) => ({
        ...prev,
        [c.taskId]: [...(prev[c.taskId] || []), c],
      }));
    });

    return () => utils.removeAllListeners?.();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [utils, isConnected, account]);

  // core loaders
  const loadBalances = async (addr = account) => {
    if (!utils || !addr) return;

    const bal = await utils.getBalance(addr);
    if (bal.success) setBalance(bal.balance);

    const w = await utils.getContractBalance(addr);
    if (w.success) setWithdrawable(w.balance);
  };

  const loadTasks = async (addr = account) => {
    if (!utils || !addr) return;

    const openRes = await utils.getAllOpenTasks();
    if (openRes.success) setOpenTasks(openRes.tasks);

    const createdRes = await utils.getTasksByCreator(addr);
    if (createdRes.success) {
      const filtered = createdRes.tasks.filter(
        (t) => t.creator?.toLowerCase?.() === addr.toLowerCase()
      );
      setMyCreatedTasks(filtered);
    }

    const workerRes = await utils.getTasksByWorker(addr);
    if (workerRes.success) {
      const filtered = workerRes.tasks.filter(
        (t) => t.worker?.toLowerCase?.() === addr.toLowerCase()
      );
      setMyWorkerTasks(filtered);
    }

    // âœ… load comments from chain (so they persist after refresh)
    if (utils.getCommentsForTask) {
      try {
        const allTasks = [
          ...(openRes.success ? openRes.tasks : []),
          ...(createdRes.success ? createdRes.tasks : []),
          ...(workerRes.success ? workerRes.tasks : []),
        ];

        const ids = Array.from(new Set(allTasks.map((t) => t?.id).filter((x) => x != null)));
        const pairs = await Promise.all(
          ids.map(async (id) => {
            const res = await utils.getCommentsForTask(id);
            return [id, res.success ? res.comments : null];
          })
        );

        setComments((prev) => {
          const next = { ...prev };
          for (const [id, list] of pairs) {
            if (Array.isArray(list)) next[id] = list;
          }
          return next;
        });
      } catch (_) {
        // ignore comment loading errors
      }
    }
  };

  const connectWallet = async () => {
    if (!utils) return;

    setLoading(true);
    setError("");
    setSuccess("");

    if (!window.ethereum) {
      setError("MetaMask is not installed. Install it from https://metamask.io/");
      setLoading(false);
      return;
    }

    const res = await utils.connectWallet();
    if (!res.success) {
      setError(`Connection failed: ${res.error}`);
      setLoading(false);
      return;
    }

    const net = await utils.getNetworkInfo();
    if (net.success) {
      setNetworkInfo(net);
      if (net.chainId !== SEPOLIA_CHAIN_ID) {
        setError(
          `Wrong network (Chain ID ${net.chainId}). Switch MetaMask to Sepolia (11155111) and reconnect.`
        );
        setAccount(res.address);
        setBalance(res.balance);
        setLoading(false);
        return;
      }
    }

    setAccount(res.address);
    setBalance(res.balance);

    await loadBalances(res.address);
    await loadTasks(res.address);

    setSuccess("Wallet connected to Sepolia âœ…");
    clearMessagesSoon();
    setLoading(false);
  };

  // actions
  const handleCreateTask = async (e) => {
    e.preventDefault();
    if (!utils) return;

    setLoading(true);
    setError("");
    setSuccess("");

    try {
      const deadlineTimestamp = Math.floor(new Date(newTask.deadline).getTime() / 1000);

      // âœ… Upload attachments to IPFS first if any exist
      let attachmentCIDs = [];
      if (attachments.length > 0) {
        setUploadingFiles(true);
        try {
          const { uploadFiles } = await import("./utils/ipfsUtils");
          const cid = await uploadFiles(attachments);
          attachmentCIDs = attachments.map((file, i) => ({
            name: file.name,
            size: file.size,
            type: file.type,
            cid: attachments.length === 1 ? cid : `${cid}/${file.name}`,
          }));
          console.log("Files uploaded to IPFS:", attachmentCIDs);
        } catch (uploadErr) {
          console.error("File upload failed:", uploadErr);
          setError(`File upload failed: ${uploadErr.message}`);
          setLoading(false);
          setUploadingFiles(false);
          return;
        }
        setUploadingFiles(false);
      }

      // âœ… IPFS upload happens automatically in utils.createTask, now with attachments
      const res = await utils.createTask(
        newTask.title,
        newTask.description,
        deadlineTimestamp,
        newTask.reward,
        { attachments: attachmentCIDs } // Pass attachments metadata
      );

      if (!res.success) {
        setError(res.error);
        setLoading(false);
        return;
      }

      const msg = `Task created${res.taskId != null ? ` (#${res.taskId})` : ""}!`;
      const ipfsInfo = res.metadataCID ? ` (Metadata: ${res.metadataCID})` : "";
      const filesInfo = attachmentCIDs.length > 0 ? ` (${attachmentCIDs.length} file${attachmentCIDs.length > 1 ? 's' : ''} attached)` : "";
      setSuccess(msg + ipfsInfo + filesInfo);
      clearMessagesSoon();

      setNewTask({ title: "", description: "", reward: "", deadline: "" });
      setAttachments([]); // Clear attachments
      setCurrentView("marketplace");

      await loadTasks(account);
      await loadBalances(account);
    } catch (err) {
      setError(err?.message || String(err));
    }

    setLoading(false);
  };

  // âœ… Handle file selection
  const handleFileSelect = (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;

    // Check file sizes (max 100MB per file)
    const maxSize = 100 * 1024 * 1024;
    const oversized = files.filter(f => f.size > maxSize);
    if (oversized.length > 0) {
      setError(`Files too large (max 100MB): ${oversized.map(f => f.name).join(', ')}`);
      clearMessagesSoon();
      return;
    }

    // Add to attachments
    setAttachments(prev => [...prev, ...files]);
  };

  // âœ… Remove attachment
  const removeAttachment = (index) => {
    setAttachments(prev => prev.filter((_, i) => i !== index));
  };

  // âœ… Format file size for display
  const formatFileSize = (bytes) => {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  };

  const handleTakeTask = async (taskId) => {
    if (!utils) return;

    setLoading(true);
    setError("");
    setSuccess("");

    const res = await utils.takeTask(taskId);
    if (res.success) {
      setSuccess(`Task #${taskId} taken!`);
      clearMessagesSoon();
      await loadTasks(account);
    } else {
      setError(res.error);
    }

    setLoading(false);
  };

  const handleSubmitWork = async (taskId) => {
    if (!utils) return;

    setLoading(true);
    setError("");
    setSuccess("");

    const res = await utils.submitWork(taskId);
    if (res.success) {
      setSuccess(`Work submitted for Task #${taskId}. Waiting approval...`);
      clearMessagesSoon();
      await loadTasks(account);
    } else {
      setError(res.error);
    }

    setLoading(false);
  };

  const handleApproveWork = async (taskId) => {
    if (!utils) return;

    setLoading(true);
    setError("");
    setSuccess("");

    const res = await utils.approveWork(taskId);
    if (res.success) {
      setSuccess(`Approved Task #${taskId}. Worker can withdraw reward now.`);
      clearMessagesSoon();
      await loadTasks(account);
      await loadBalances(account);
    } else {
      setError(res.error);
    }

    setLoading(false);
  };

  const handleCancelTask = async (taskId) => {
    if (!utils) return;

    setLoading(true);
    setError("");
    setSuccess("");

    const res = await utils.cancelTask(taskId);
    if (res.success) {
      setSuccess(`Task #${taskId} cancelled.`);
      clearMessagesSoon();
      await loadTasks(account);
      await loadBalances(account);
    } else {
      setError(res.error);
    }

    setLoading(false);
  };

  const handleWithdraw = async () => {
    if (!utils) return;

    setLoading(true);
    setError("");
    setSuccess("");

    const res = await utils.withdraw();
    if (res.success) {
      setSuccess("Withdrawal successful!");
      clearMessagesSoon();
      await loadBalances(account);
    } else {
      setError(res.error);
    }

    setLoading(false);
  };

  // optional: add comment (only if utils.addComment exists)
  const handleAddComment = async (taskId) => {
    const msg = commentInput[taskId];
    if (!msg || !utils?.addComment) return;

    try {
      setLoading(true);
      const res = await utils.addComment(taskId, msg);
      if (!res?.success) throw new Error(res?.error || "Failed to add comment");

      // Clear input immediately
      setCommentInput((prev) => ({ ...prev, [taskId]: "" }));

      // âœ… refresh comments for this task so UI updates even if the event doesn't fire
      if (utils.getCommentsForTask) {
        const c = await utils.getCommentsForTask(taskId);
        if (c.success) {
          setComments((prev) => ({ ...prev, [taskId]: c.comments }));
        }
      }
    } catch (e) {
      setError(e?.message || String(e));
      clearMessagesSoon();
    } finally {
      setLoading(false);
    }
  };

  // âœ… View task details
  const handleViewTask = async (taskId) => {
    if (!utils) return;
    
    setLoading(true);
    const res = await utils.getTask(taskId);
    
    if (res.success) {
      setSelectedTask(res.task);
      setSelectedTaskId(taskId);
      setCurrentView("taskDetail");
      
      // Load comments for this task
      if (utils.getCommentsForTask) {
        const commentsRes = await utils.getCommentsForTask(taskId);
        if (commentsRes.success) {
          setComments(prev => ({ ...prev, [taskId]: commentsRes.comments }));
        }
      }
    } else {
      setError(`Failed to load task: ${res.error}`);
    }
    
    setLoading(false);
  };

  // âœ… Go back from task detail view
  const handleBackFromDetail = () => {
    setCurrentView("marketplace");
    setSelectedTask(null);
    setSelectedTaskId(null);
  };

  // ---------------- UI ----------------

  if (!account) {
    return (
      <div className="app connect-page">
        <div className="connect-container">
          <h1>ğŸ¯ Task Marketplace</h1>
          <p>A decentralized task platform on Sepolia (escrow + approvals)</p>

          <button onClick={connectWallet} disabled={loading} className="btn-primary">
            {loading ? "Connecting..." : "Connect Wallet"}
          </button>

          {error && <div className="error">{error}</div>}

          {!SEPOLIA_CONTRACT_ADDRESS?.startsWith("0x") && (
            <div className="warning">
              âš ï¸ Contract address not configured. Update SEPOLIA_CONTRACT_ADDRESS in App.jsx
            </div>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="app">
      <div className="container">
        <header className="header">
          <h1>ğŸ¯ Task Marketplace</h1>

          <div className="account-info">
            <div className="info-item">
              <span className="label">Account:</span>
              <span className="value">{formatAddress(account)}</span>
              <button
                onClick={handleDisconnect}
                className="btn-disconnect"
                title="Clear UI connection (for switching accounts)"
              >
                ğŸ”„ Switch
              </button>
            </div>

            <div className="info-item">
              <span className="label">Balance:</span>
              <span className="value">{Number(balance).toFixed(4)} ETH</span>
            </div>

            <div className="info-item">
              <span className="label">Withdrawable:</span>
              <span className="value">{Number(withdrawable).toFixed(4)} ETH</span>
              {Number(withdrawable) > 0 && (
                <button onClick={handleWithdraw} className="btn-small" disabled={loading}>
                  Withdraw
                </button>
              )}
            </div>

            {networkInfo && (
              <div className="info-item">
                <span className="label">Network:</span>
                <span className="value">
                  {networkInfo.name} (Chain ID {networkInfo.chainId})
                </span>
              </div>
            )}
          </div>
        </header>

        {wrongNetwork && (
          <div className="error">âŒ Wrong network! Switch MetaMask to Sepolia (Chain ID 11155111).</div>
        )}

        <nav className="nav">
          <button
            className={currentView === "marketplace" ? "active" : ""}
            onClick={() => setCurrentView("marketplace")}
          >
            ğŸª Marketplace
          </button>
          <button
            className={currentView === "myTasks" ? "active" : ""}
            onClick={() => setCurrentView("myTasks")}
          >
            ğŸ“‹ My Tasks
          </button>
          <button
            className={currentView === "create" ? "active" : ""}
            onClick={() => setCurrentView("create")}
          >
            â• Create Task
          </button>
        </nav>

        {error && <div className="error">{error}</div>}
        {success && <div className="success">{success}</div>}

        <main className="main">
          {/* Marketplace */}
          {currentView === "marketplace" && (
            <div className="marketplace">
              <h2>Open Tasks</h2>

              <div className="filters-bar">
                <div className="search-wrap"></div>
                  <span className="search-icon">ğŸ”</span>
                  <input
                    className="search-input"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    placeholder="Search by title, description, creator, worker, id..."
                  />
                  {searchQuery && (
                    <button
                      className="chip-btn"
                      type="button"
                      onClick={() => setSearchQuery("")}
                      title="Clear search"
                    >
                      âœ•
                    </button>
                  )}
                </div>

                <select
                  className="select"
                  value={statusFilter}
                  onChange={(e) => setStatusFilter(e.target.value)}
                  title="Filter by status"
                >
                  <option value="all">All statuses</option>
                  <option value="open">Open</option>
                  <option value="inprogress">In Progress</option>
                  <option value="pendingapproval">Pending Approval</option>
                  <option value="completed">Completed</option>
                  <option value="cancelled">Cancelled</option>
                </select>

                <select
                  className="select"
                  value={sortBy}
                  onChange={(e) => setSortBy(e.target.value)}
                  title="Sort"
                >
                  <option value="newest">Newest</option>
                  <option value="deadlineSoon">Deadline soon</option>
                  <option value="rewardHigh">Reward high â†’ low</option>
                  <option value="rewardLow">Reward low â†’ high</option>
                </select>
              </div>

              <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
                <button
                  className="btn-small"
                  disabled={loading}
                  onClick={async () => {
                    setLoading(true);
                    await loadTasks(account);
                    await loadBalances(account);
                    setLoading(false);
                  }}
                >
                  ğŸ”„ Refresh
                </button>
              </div>

              {openTasks.length === 0 ? (
                <p className="empty-state">No open tasks available</p>
              ) : filteredOpen.length === 0 ? (
                <p className="empty-state">No results for your search/filter ğŸ˜­</p>
              ) : (
                <div className="tasks-grid">
                  {filteredOpen.map((task) => {
                    const isCreator = task.creator?.toLowerCase?.() === account.toLowerCase();
                    const isOpen = task.status === STATUS.Open;

                    return (
                      <div key={task.id} className="task-card">
                        <div className="task-header">
                          <h3>{task.title}</h3>
                          <span className="reward">ğŸ’° {task.reward} ETH</span>
                        </div>

                        <p className="description">{task.description}</p>

                        {/* âœ… Display attachments if they exist */}
                        {task.metadata?.attachments && task.metadata.attachments.length > 0 && (
                          <div className="task-attachments">
                            <h4>ğŸ“ Attachments</h4>
                            <ul>
                              {task.metadata.attachments.map((att, idx) => (
                                <li key={idx}>
                                  <span>ğŸ“„ {att.name}</span>
                                  <a 
                                    href={`https://w3s.link/ipfs/${att.cid}`} 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                  >
                                    View
                                  </a>
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}

                        <div className="task-meta">
                          <span>ğŸ“… Deadline: {formatDateTime(task.deadline)}</span>
                          <span>ğŸ‘¤ Creator: {formatAddress(task.creator)}</span>
                        </div>

                        {isCreator ? (
                          <button
                            onClick={() => handleCancelTask(task.id)}
                            disabled={loading || !isOpen || wrongNetwork}
                            className="btn-danger"
                          >
                            Cancel Task
                          </button>
                        ) : (
                          <button
                            onClick={() => handleTakeTask(task.id)}
                            disabled={loading || !isOpen || wrongNetwork}
                            className="btn-primary"
                          >
                            Take Task
                          </button>
                        )}
                        <button
                          onClick={() => handleViewTask(task.id)}
                          disabled={loading}
                          className="btn-secondary"
                        >
                          View Details
                        </button>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          )}

          {/* My Tasks */}
          {currentView === "myTasks" && (
            <div className="my-tasks">
              <section>
                <h2>Tasks I Created</h2>

                {myCreatedTasks.length === 0 ? (
                  <p className="empty-state">You haven't created any tasks yet</p>
                ) : (
                  <div className="tasks-grid">
                    {myCreatedTasks.map((task) => {
                      const workerSet =
                        task.worker && task.worker.toLowerCase() !== ZERO_ADDR.toLowerCase();

                      return (
                        <div key={task.id} className="task-card">
                          <div className="task-header">
                            <h3>{task.title}</h3>
                            <span className={`status status-${task.statusText.toLowerCase()}`}>
                              {task.statusText}
                            </span>
                          </div>

                          <p className="description">{task.description}</p>

                          <div className="task-meta">
                            <span>ğŸ’° Reward: {task.reward} ETH</span>
                            <span>ğŸ“… Deadline: {formatDateTime(task.deadline)}</span>
                            {workerSet && <span>ğŸ‘· Worker: {formatAddress(task.worker)}</span>}
                          </div>

                          {task.status === STATUS.Open && (
                            <div className="button-group">
                              <button
                                onClick={() => handleCancelTask(task.id)}
                                disabled={loading || wrongNetwork}
                                className="btn-danger"
                              >
                                Cancel Task
                              </button>
                            </div>
                          )}

                          {task.status === STATUS.PendingApproval && (
                            <div className="button-group">
                              <button
                                onClick={() => handleApproveWork(task.id)}
                                disabled={loading || wrongNetwork}
                                className="btn-success"
                              >
                                âœ… Approve Work & Release Payment
                              </button>
                            </div>
                          )}

                          {task.status === STATUS.InProgress && (
                            <div className="pending-approval">â³ In progress (waiting for submit)</div>
                          )}

                          {task.status === STATUS.Completed && (
                            <div className="completion-message">âœ… Completed & approved</div>
                          )}

                          {task.status === STATUS.Cancelled && (
                            <div className="completion-message">ğŸš« Cancelled</div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                )}
              </section>

              <section>
                <h2>Tasks I'm Working On</h2>

                {myWorkerTasks.length === 0 ? (
                  <p className="empty-state">You haven't taken any tasks yet</p>
                ) : (
                  <div className="tasks-grid">
                    {myWorkerTasks.map((task) => (
                      <div key={task.id} className="task-card">
                        <div className="task-header">
                          <h3>{task.title}</h3>
                          <span className={`status status-${task.statusText.toLowerCase()}`}>
                            {task.statusText}
                          </span>
                        </div>

                        <p className="description">{task.description}</p>

                        <div className="task-meta">
                          <span>ğŸ’° Reward: {task.reward} ETH</span>
                          <span>ğŸ“… Deadline: {formatDateTime(task.deadline)}</span>
                          <span>ğŸ‘¤ Creator: {formatAddress(task.creator)}</span>
                        </div>

                        {task.status === STATUS.InProgress && (
                          <button
                            onClick={() => handleSubmitWork(task.id)}
                            disabled={loading || wrongNetwork}
                            className="btn-success"
                          >
                            âœ… Submit Work for Review
                          </button>
                        )}

                        {task.status === STATUS.PendingApproval && (
                          <div className="pending-approval">â³ Waiting for creator approval...</div>
                        )}

                        {task.status === STATUS.Completed && (
                          <div className="completion-message">âœ… Approved! Reward is withdrawable.</div>
                        )}

                        {task.status === STATUS.Cancelled && (
                          <div className="completion-message">ğŸš« Cancelled</div>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </section>
            </div>
          )}

          {/* Create */}
          {currentView === "create" && (
            <div className="create-task">
              <h2>Create New Task</h2>

              <form onSubmit={handleCreateTask}>
                <div className="form-group">
                  <label htmlFor="title">Task Title *</label>
                  <input
                    type="text"
                    id="title"
                    value={newTask.title}
                    onChange={(e) => setNewTask({ ...newTask, title: e.target.value })}
                    required
                    maxLength={100}
                    placeholder="e.g., Make a landing page"
                    disabled={wrongNetwork}
                  />
                </div>

                <div className="form-group">
                  <label htmlFor="description">Description *</label>
                  <textarea
                    id="description"
                    value={newTask.description}
                    onChange={(e) => setNewTask({ ...newTask, description: e.target.value })}
                    required
                    maxLength={1000}
                    rows={4}
                    placeholder="Describe what needs to be done..."
                    disabled={wrongNetwork}
                  />
                </div>

                <div className="form-row">
                  <div className="form-group">
                    <label htmlFor="reward">Reward (ETH) *</label>
                    <input
                      type="number"
                      id="reward"
                      value={newTask.reward}
                      onChange={(e) => setNewTask({ ...newTask, reward: e.target.value })}
                      required
                      step="0.001"
                      min="0.001"
                      placeholder="0.05"
                      disabled={wrongNetwork}
                    />
                  </div>

                  <div className="form-group">
                    <label htmlFor="deadline">Deadline *</label>
                    <input
                      type="datetime-local"
                      id="deadline"
                      value={newTask.deadline}
                      onChange={(e) => setNewTask({ ...newTask, deadline: e.target.value })}
                      required
                      min={new Date().toISOString().slice(0, 16)}
                      disabled={wrongNetwork}
                    />
                  </div>
                </div>

                {/* âœ… File attachments */}
                <div className="form-group">
                  <label htmlFor="attachments">Attachments (optional, max 100MB each)</label>
                  <input
                    type="file"
                    id="attachments"
                    multiple
                    onChange={handleFileSelect}
                    disabled={wrongNetwork || uploadingFiles}
                  />
                  {attachments.length > 0 && (
                    <ul className="attachments-list"></ul>
                      {attachments.map((file, index) => (
                        <li key={index}></li>
                          {file.name} ({formatFileSize(file.size)})
                          <button
                            type="button"
                            onClick={() => removeAttachment(index)}
                            disabled={uploadingFiles}
                          >
                            âœ•
                          </button>
                        </li>
                      ))}
                    </ul>
                  )}
                </div>

                <button type="submit" disabled={loading || wrongNetwork} className="btn-primary"></button>
                  {loading ? "Creating..." : "Create Task"}
                </button>

                {wrongNetwork && (
                  <div className="warning" style={{ marginTop: 12 }}></div>
                    Switch MetaMask to Sepolia to create tasks.
                  </div>
                )}
              </form>
            </div>
          )}

          {/* Task Detail */}
          {currentView === "taskDetail" && selectedTask && (
            <div className="task-detail"></div>
              <button onClick={handleBackFromDetail} className="btn-back">
                â† Back to Marketplace
              </button>

              <h2>Task Details</h2>

              <div className="task-card">
                <div className="task-header">
                  <h3>{selectedTask.title}</h3>
                  <span className="reward">ğŸ’° {selectedTask.reward} ETH</span>
                </div>

                <p className="description">{selectedTask.description}</p>

                {/* âœ… Display attachments if they exist */}
                {selectedTask.metadata?.attachments && selectedTask.metadata.attachments.length > 0 && (
                  <div className="task-attachments"></div>
                    <h4>ğŸ“ Attachments</h4>
                    <ul>
                      {selectedTask.metadata.attachments.map((att, idx) => (
                        <li key={idx}></li>
                          <span>ğŸ“„ {att.name}</span>
                          <a 
                            href={`https://w3s.link/ipfs/${att.cid}`} 
                            target="_blank" 
                            rel="noopener noreferrer"
                          >
                            View
                          </a>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}

                <div className="task-meta"></div>
                  <span>ğŸ“… Deadline: {formatDateTime(selectedTask.deadline)}</span>
                  <span>ğŸ‘¤ Creator: {formatAddress(selectedTask.creator)}</span>
                  {selectedTask.worker && (
                    <span>ğŸ‘· Worker: {formatAddress(selectedTask.worker)}</span>
                  )}
                </div>

                <div className="task-actions"></div>
                  {selectedTask.status === STATUS.Open && (
                    <button
                      onClick={() => handleTakeTask(selectedTask.id)}
                      disabled={loading || wrongNetwork}
                      className="btn-primary"
                    >
                      Take Task
                    </button>
                  )}

                  {selectedTask.status === STATUS.PendingApproval && (
                    <button
                      onClick={() => handleApproveWork(selectedTask.id)}
                      disabled={loading || wrongNetwork}
                      className="btn-success"
                    ></button>
                      âœ… Approve Work & Release Payment
                    </button>
                  )}

                  {selectedTask.status === STATUS.InProgress && (
                    <button
                      onClick={() => handleSubmitWork(selectedTask.id)}
                      disabled={loading || wrongNetwork}
                      className="btn-success"
                    >
                      âœ… Submit Work for Review
                    </button>
                  )}

                  {selectedTask.status === STATUS.Cancelled && (
                    <div className="completion-message">ğŸš« Cancelled</div>
                  )}

                  {selectedTask.status === STATUS.Completed && (
                    <div className="completion-message">âœ… Completed & approved</div>
                  )}
                </div>

                {/* Comments */}
                <div className="comments-section">
                  <h4>Comments</h4>
                  {comments[selectedTask.id]?.length > 0 ? (
                    <ul className="comments-list"></ul>
                      {comments[selectedTask.id].map((comment, idx) => (
                        <li key={idx}></li>
                          <span className="comment-author">{formatAddress(comment.author)}</span>
                          <span className="comment-message">{comment.message}</span>
                          <span className="comment-timestamp">{formatDateTime(comment.timestamp)}</span>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <p>No comments yet.</p>
                  )}

                  <div className="add-comment">
                    <textarea
                      value={commentInput[selectedTask.id] || ""}
                      onChange={(e) =>
                        setCommentInput((prev) => ({ ...prev, [selectedTask.id]: e.target.value }))
                      }
                      placeholder="Add a comment..."
                      rows={3}
                    />
                    <button
                      onClick={() => handleAddComment(selectedTask.id)}
                      disabled={loading || !commentInput[selectedTask.id]}
                      className="btn-primary"
                    >
                      Add Comment
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}
        </main>
      </div>
    </div>
  );
}
